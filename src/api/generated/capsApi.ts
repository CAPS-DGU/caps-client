/**
 * Generated by orval v8.0.3 üç∫
 * Do not edit manually.
 * CAPS ÌôàÌéòÏù¥ÏßÄ
 * CAPS Homepage v4.0.0
 * OpenAPI spec version: 1.0.0
 */
import {
  useMutation,
  useQuery
} from '@tanstack/react-query';
import type {
  DataTag,
  DefinedInitialDataOptions,
  DefinedUseQueryResult,
  MutationFunction,
  QueryClient,
  QueryFunction,
  QueryKey,
  UndefinedInitialDataOptions,
  UseMutationOptions,
  UseMutationResult,
  UseQueryOptions,
  UseQueryResult
} from '@tanstack/react-query';

import { orvalClient } from '../../utils/orvalClient';
export interface CreateOrModifyWikiRequest {
  /** @minLength 1 */
  title?: string;
  /** @minLength 1 */
  content?: string;
}

export interface MemberSummary {
  id?: number;
  name?: string;
  profileImageUrl?: string;
  grade?: number;
}

export interface WikiResponse {
  title?: string;
  content?: string;
  member?: MemberSummary;
  createdAt?: string;
  updatedAt?: string;
}

export type SuccessResponseObjectData = { [key: string]: unknown };

export interface SuccessResponseObject {
  status?: number;
  message?: string;
  data?: SuccessResponseObjectData;
}

export type CreateReportRequestCategory = typeof CreateReportRequestCategory[keyof typeof CreateReportRequestCategory];


export const CreateReportRequestCategory = {
  INFO_ERROR: 'INFO_ERROR',
  ACCOUNT_MANAGEMENT: 'ACCOUNT_MANAGEMENT',
  SUGGESTION: 'SUGGESTION',
  USER_REPORT_AND_SECURITY_REPORT: 'USER_REPORT_AND_SECURITY_REPORT',
  ETC: 'ETC',
} as const;

export interface CreateReportRequest {
  /** @minLength 1 */
  content?: string;
  fileUrls?: string[];
  category?: CreateReportRequestCategory;
}

export type ReportResponseCategory = typeof ReportResponseCategory[keyof typeof ReportResponseCategory];


export const ReportResponseCategory = {
  INFO_ERROR: 'INFO_ERROR',
  ACCOUNT_MANAGEMENT: 'ACCOUNT_MANAGEMENT',
  SUGGESTION: 'SUGGESTION',
  USER_REPORT_AND_SECURITY_REPORT: 'USER_REPORT_AND_SECURITY_REPORT',
  ETC: 'ETC',
} as const;

export interface ReportResponse {
  id?: number;
  content?: string;
  category?: ReportResponseCategory;
  fileUrls?: string[];
}

export interface CreateOrModifyLedgerRequest {
  /** @minLength 1 */
  title?: string;
  /** @minLength 1 */
  content?: string;
  fileUrls?: string[];
  isPinned?: boolean;
}

export interface LedgerResponse {
  id?: number;
  title?: string;
  content?: string;
  fileUrls?: string[];
  member?: MemberSummary;
  createdAt?: string;
  isPinned?: boolean;
}

export interface PresignedUrlRequest {
  /** @minLength 1 */
  fileName?: string;
  fileType?: string;
}

export interface UpdateMemberRequest {
  /**
   * @minLength 0
   * @maxLength 127
   */
  comment?: string;
  /**
   * @minLength 0
   * @maxLength 500
   */
  profileImageUrl?: string;
}

export type MemberInfoResponseRole = typeof MemberInfoResponseRole[keyof typeof MemberInfoResponseRole];


export const MemberInfoResponseRole = {
  NEW_MEMBER: 'NEW_MEMBER',
  MEMBER: 'MEMBER',
  GRADUATE: 'GRADUATE',
  COUNCIL: 'COUNCIL',
  PRESIDENT: 'PRESIDENT',
  ADMIN: 'ADMIN',
} as const;

export interface MemberInfoResponse {
  id?: number;
  role?: MemberInfoResponseRole;
  name?: string;
  studentNumber?: string;
  grade?: number;
  email?: string;
  phoneNumber?: string;
  comment?: string;
  profileImageUrl?: string;
  registrationComplete?: boolean;
  isDeleted?: boolean;
}

export interface CompleteRegistrationRequest {
  /**
   * @minLength 1
   * @pattern ^[0-9]{10}$
   */
  studentNumber?: string;
  /** @minimum 0 */
  grade: number;
  /**
   * @minLength 1
   * @pattern ^\d{2,3}-\d{3,4}-\d{4}$
   */
  phoneNumber?: string;
}

export interface WikiTitleResponse {
  title?: string;
}

export interface LedgerListResponse {
  id?: number;
  title?: string;
  member?: MemberSummary;
  createdAt?: string;
  isPinned?: boolean;
  hasFile?: boolean;
}

export type GetLedgersListParams = {
/**
 * @minimum 1
 */
page?: number;
};

export type GetPresignedDownloadUrlParams = {
/**
 * @minLength 1
 */
key: string;
};

export type GetAutocompleteWikiParams = {
input: string;
};

export type DeleteFileParams = {
/**
 * @minLength 1
 */
key: string;
};

type AwaitedInput<T> = PromiseLike<T> | T;

      type Awaited<O> = O extends AwaitedInput<infer T> ? T : never;




/**
 * ÏúÑÌÇ§Î•º ÏûëÏÑ±Ìï©ÎãàÎã§.
 * @summary ÏúÑÌÇ§ ÏûëÏÑ±
 */
export type createWikiResponse201 = {
  data: WikiResponse
  status: 201
}

export type createWikiResponse409 = {
  data: Blob
  status: 409
}
    
export type createWikiResponseSuccess = (createWikiResponse201) & {
  headers: Headers;
};
export type createWikiResponseError = (createWikiResponse409) & {
  headers: Headers;
};

export type createWikiResponse = (createWikiResponseSuccess | createWikiResponseError)

export const getCreateWikiUrl = () => {


  

  return `/api/v1/wikis`
}

export const createWiki = async (createWikiBody: Blob, options?: RequestInit): Promise<createWikiResponse> => {
  
  return orvalClient<createWikiResponse>(getCreateWikiUrl(),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json;charset=UTF-8', ...options?.headers },
    body: JSON.stringify(
      createWikiBody,)
  }
);}




export const getCreateWikiMutationOptions = <TError = Blob,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createWiki>>, TError,{data: Blob}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof createWiki>>, TError,{data: Blob}, TContext> => {

const mutationKey = ['createWiki'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof createWiki>>, {data: Blob}> = (props) => {
          const {data} = props ?? {};

          return  createWiki(data,)
        }



        


  return  { mutationFn, ...mutationOptions }}

    export type CreateWikiMutationResult = NonNullable<Awaited<ReturnType<typeof createWiki>>>
    export type CreateWikiMutationBody = Blob
    export type CreateWikiMutationError = Blob

    /**
 * @summary ÏúÑÌÇ§ ÏûëÏÑ±
 */
export const useCreateWiki = <TError = Blob,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createWiki>>, TError,{data: Blob}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof createWiki>>,
        TError,
        {data: Blob},
        TContext
      > => {
      return useMutation(getCreateWikiMutationOptions(options), queryClient);
    }
    
/**
 * ÏúÑÌÇ§Î•º ÏàòÏ†ïÌï©ÎãàÎã§.
 * @summary ÏúÑÌÇ§ ÏàòÏ†ï
 */
export type modifyWikiResponse200 = {
  data: WikiResponse
  status: 200
}
    
export type modifyWikiResponseSuccess = (modifyWikiResponse200) & {
  headers: Headers;
};
;

export type modifyWikiResponse = (modifyWikiResponseSuccess)

export const getModifyWikiUrl = () => {


  

  return `/api/v1/wikis`
}

export const modifyWiki = async (modifyWikiBody: Blob, options?: RequestInit): Promise<modifyWikiResponse> => {
  
  return orvalClient<modifyWikiResponse>(getModifyWikiUrl(),
  {      
    ...options,
    method: 'PATCH',
    headers: { 'Content-Type': 'application/json;charset=UTF-8', ...options?.headers },
    body: JSON.stringify(
      modifyWikiBody,)
  }
);}




export const getModifyWikiMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof modifyWiki>>, TError,{data: Blob}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof modifyWiki>>, TError,{data: Blob}, TContext> => {

const mutationKey = ['modifyWiki'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof modifyWiki>>, {data: Blob}> = (props) => {
          const {data} = props ?? {};

          return  modifyWiki(data,)
        }



        


  return  { mutationFn, ...mutationOptions }}

    export type ModifyWikiMutationResult = NonNullable<Awaited<ReturnType<typeof modifyWiki>>>
    export type ModifyWikiMutationBody = Blob
    export type ModifyWikiMutationError = unknown

    /**
 * @summary ÏúÑÌÇ§ ÏàòÏ†ï
 */
export const useModifyWiki = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof modifyWiki>>, TError,{data: Blob}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof modifyWiki>>,
        TError,
        {data: Blob},
        TContext
      > => {
      return useMutation(getModifyWikiMutationOptions(options), queryClient);
    }
    
/**
 * Î¨∏Ïùò Î∞è Ïã†Í≥† ÎÇ¥Ïö©ÏùÑ ÏÑúÎ≤ÑÏóê Ï†úÏ∂úÌï©ÎãàÎã§
 * @summary Î¨∏Ïùò Î∞è Ïã†Í≥† ÏûëÏÑ±
 */
export type createReportResponse200 = {
  data: ReportResponse
  status: 200
}
    
export type createReportResponseSuccess = (createReportResponse200) & {
  headers: Headers;
};
;

export type createReportResponse = (createReportResponseSuccess)

export const getCreateReportUrl = () => {


  

  return `/api/v1/report`
}

export const createReport = async (createReportBody: Blob, options?: RequestInit): Promise<createReportResponse> => {
  
  return orvalClient<createReportResponse>(getCreateReportUrl(),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json;charset=UTF-8', ...options?.headers },
    body: JSON.stringify(
      createReportBody,)
  }
);}




export const getCreateReportMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createReport>>, TError,{data: Blob}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof createReport>>, TError,{data: Blob}, TContext> => {

const mutationKey = ['createReport'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof createReport>>, {data: Blob}> = (props) => {
          const {data} = props ?? {};

          return  createReport(data,)
        }



        


  return  { mutationFn, ...mutationOptions }}

    export type CreateReportMutationResult = NonNullable<Awaited<ReturnType<typeof createReport>>>
    export type CreateReportMutationBody = Blob
    export type CreateReportMutationError = unknown

    /**
 * @summary Î¨∏Ïùò Î∞è Ïã†Í≥† ÏûëÏÑ±
 */
export const useCreateReport = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createReport>>, TError,{data: Blob}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof createReport>>,
        TError,
        {data: Blob},
        TContext
      > => {
      return useMutation(getCreateReportMutationOptions(options), queryClient);
    }
    
/**
 * Í≤åÏãúÎ¨ºÏùò Î™©Î°ùÏùÑ ÌôïÏù∏Ìï©ÎãàÎã§
 * @summary Í≤åÏãúÎ¨º Î™©Î°ù Ï°∞Ìöå
 */
export type getLedgersListResponse200 = {
  data: LedgerListResponse
  status: 200
}
    
export type getLedgersListResponseSuccess = (getLedgersListResponse200) & {
  headers: Headers;
};
;

export type getLedgersListResponse = (getLedgersListResponseSuccess)

export const getGetLedgersListUrl = (params?: GetLedgersListParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `/api/v1/ledgers?${stringifiedParams}` : `/api/v1/ledgers`
}

export const getLedgersList = async (params?: GetLedgersListParams, options?: RequestInit): Promise<getLedgersListResponse> => {
  
  return orvalClient<getLedgersListResponse>(getGetLedgersListUrl(params),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}





export const getGetLedgersListQueryKey = (params?: GetLedgersListParams,) => {
    return [
    `/api/v1/ledgers`, ...(params ? [params] : [])
    ] as const;
    }

    
export const getGetLedgersListQueryOptions = <TData = Awaited<ReturnType<typeof getLedgersList>>, TError = unknown>(params?: GetLedgersListParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getLedgersList>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetLedgersListQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getLedgersList>>> = ({ signal }) => getLedgersList(params, { signal });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getLedgersList>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetLedgersListQueryResult = NonNullable<Awaited<ReturnType<typeof getLedgersList>>>
export type GetLedgersListQueryError = unknown


export function useGetLedgersList<TData = Awaited<ReturnType<typeof getLedgersList>>, TError = unknown>(
 params: undefined |  GetLedgersListParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getLedgersList>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getLedgersList>>,
          TError,
          Awaited<ReturnType<typeof getLedgersList>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetLedgersList<TData = Awaited<ReturnType<typeof getLedgersList>>, TError = unknown>(
 params?: GetLedgersListParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getLedgersList>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getLedgersList>>,
          TError,
          Awaited<ReturnType<typeof getLedgersList>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetLedgersList<TData = Awaited<ReturnType<typeof getLedgersList>>, TError = unknown>(
 params?: GetLedgersListParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getLedgersList>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Í≤åÏãúÎ¨º Î™©Î°ù Ï°∞Ìöå
 */

export function useGetLedgersList<TData = Awaited<ReturnType<typeof getLedgersList>>, TError = unknown>(
 params?: GetLedgersListParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getLedgersList>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetLedgersListQueryOptions(params,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  return { ...query, queryKey: queryOptions.queryKey };
}





/**
 * ÏÉàÎ°úÏö¥ Í≤åÏãúÎ¨ºÏùÑ Ïû•Î∂Ä Í≤åÏãúÌåêÏóê Îì±Î°ùÌï©ÎãàÎã§
 * @summary Í≤åÏãúÎ¨º Îì±Î°ù
 */
export type createLedgerResponse201 = {
  data: LedgerResponse
  status: 201
}

export type createLedgerResponse401 = {
  data: Blob
  status: 401
}
    
export type createLedgerResponseSuccess = (createLedgerResponse201) & {
  headers: Headers;
};
export type createLedgerResponseError = (createLedgerResponse401) & {
  headers: Headers;
};

export type createLedgerResponse = (createLedgerResponseSuccess | createLedgerResponseError)

export const getCreateLedgerUrl = () => {


  

  return `/api/v1/ledgers`
}

export const createLedger = async (createLedgerBody: Blob, options?: RequestInit): Promise<createLedgerResponse> => {
  
  return orvalClient<createLedgerResponse>(getCreateLedgerUrl(),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json;charset=UTF-8', ...options?.headers },
    body: JSON.stringify(
      createLedgerBody,)
  }
);}




export const getCreateLedgerMutationOptions = <TError = Blob,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createLedger>>, TError,{data: Blob}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof createLedger>>, TError,{data: Blob}, TContext> => {

const mutationKey = ['createLedger'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof createLedger>>, {data: Blob}> = (props) => {
          const {data} = props ?? {};

          return  createLedger(data,)
        }



        


  return  { mutationFn, ...mutationOptions }}

    export type CreateLedgerMutationResult = NonNullable<Awaited<ReturnType<typeof createLedger>>>
    export type CreateLedgerMutationBody = Blob
    export type CreateLedgerMutationError = Blob

    /**
 * @summary Í≤åÏãúÎ¨º Îì±Î°ù
 */
export const useCreateLedger = <TError = Blob,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createLedger>>, TError,{data: Blob}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof createLedger>>,
        TError,
        {data: Blob},
        TContext
      > => {
      return useMutation(getCreateLedgerMutationOptions(options), queryClient);
    }
    
export type getPresignedDownloadUrlResponse200 = {
  data: Blob
  status: 200
}
    
export type getPresignedDownloadUrlResponseSuccess = (getPresignedDownloadUrlResponse200) & {
  headers: Headers;
};
;

export type getPresignedDownloadUrlResponse = (getPresignedDownloadUrlResponseSuccess)

export const getGetPresignedDownloadUrlUrl = (params: GetPresignedDownloadUrlParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `/api/v1/files/presigned-url?${stringifiedParams}` : `/api/v1/files/presigned-url`
}

export const getPresignedDownloadUrl = async (params: GetPresignedDownloadUrlParams, options?: RequestInit): Promise<getPresignedDownloadUrlResponse> => {
  
  return orvalClient<getPresignedDownloadUrlResponse>(getGetPresignedDownloadUrlUrl(params),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}





export const getGetPresignedDownloadUrlQueryKey = (params?: GetPresignedDownloadUrlParams,) => {
    return [
    `/api/v1/files/presigned-url`, ...(params ? [params] : [])
    ] as const;
    }

    
export const getGetPresignedDownloadUrlQueryOptions = <TData = Awaited<ReturnType<typeof getPresignedDownloadUrl>>, TError = unknown>(params: GetPresignedDownloadUrlParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getPresignedDownloadUrl>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetPresignedDownloadUrlQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getPresignedDownloadUrl>>> = ({ signal }) => getPresignedDownloadUrl(params, { signal });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getPresignedDownloadUrl>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetPresignedDownloadUrlQueryResult = NonNullable<Awaited<ReturnType<typeof getPresignedDownloadUrl>>>
export type GetPresignedDownloadUrlQueryError = unknown


export function useGetPresignedDownloadUrl<TData = Awaited<ReturnType<typeof getPresignedDownloadUrl>>, TError = unknown>(
 params: GetPresignedDownloadUrlParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getPresignedDownloadUrl>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getPresignedDownloadUrl>>,
          TError,
          Awaited<ReturnType<typeof getPresignedDownloadUrl>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetPresignedDownloadUrl<TData = Awaited<ReturnType<typeof getPresignedDownloadUrl>>, TError = unknown>(
 params: GetPresignedDownloadUrlParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getPresignedDownloadUrl>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getPresignedDownloadUrl>>,
          TError,
          Awaited<ReturnType<typeof getPresignedDownloadUrl>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetPresignedDownloadUrl<TData = Awaited<ReturnType<typeof getPresignedDownloadUrl>>, TError = unknown>(
 params: GetPresignedDownloadUrlParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getPresignedDownloadUrl>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

export function useGetPresignedDownloadUrl<TData = Awaited<ReturnType<typeof getPresignedDownloadUrl>>, TError = unknown>(
 params: GetPresignedDownloadUrlParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getPresignedDownloadUrl>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetPresignedDownloadUrlQueryOptions(params,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  return { ...query, queryKey: queryOptions.queryKey };
}





export type getPresignedUrlResponse200 = {
  data: Blob
  status: 200
}
    
export type getPresignedUrlResponseSuccess = (getPresignedUrlResponse200) & {
  headers: Headers;
};
;

export type getPresignedUrlResponse = (getPresignedUrlResponseSuccess)

export const getGetPresignedUrlUrl = () => {


  

  return `/api/v1/files/presigned-url`
}

export const getPresignedUrl = async (getPresignedUrlBody: Blob, options?: RequestInit): Promise<getPresignedUrlResponse> => {
  
  return orvalClient<getPresignedUrlResponse>(getGetPresignedUrlUrl(),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json;charset=UTF-8', ...options?.headers },
    body: JSON.stringify(
      getPresignedUrlBody,)
  }
);}




export const getGetPresignedUrlMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof getPresignedUrl>>, TError,{data: Blob}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof getPresignedUrl>>, TError,{data: Blob}, TContext> => {

const mutationKey = ['getPresignedUrl'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof getPresignedUrl>>, {data: Blob}> = (props) => {
          const {data} = props ?? {};

          return  getPresignedUrl(data,)
        }



        


  return  { mutationFn, ...mutationOptions }}

    export type GetPresignedUrlMutationResult = NonNullable<Awaited<ReturnType<typeof getPresignedUrl>>>
    export type GetPresignedUrlMutationBody = Blob
    export type GetPresignedUrlMutationError = unknown

    export const useGetPresignedUrl = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof getPresignedUrl>>, TError,{data: Blob}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof getPresignedUrl>>,
        TError,
        {data: Blob},
        TContext
      > => {
      return useMutation(getGetPresignedUrlMutationOptions(options), queryClient);
    }
    
/**
 * Î¶¨ÌîÑÎ†àÏâ¨ ÌÜ†ÌÅ∞ÏùÑ Ïù¥Ïö©ÌïòÏó¨ ÌÜ†ÌÅ∞ÏùÑ Ïû¨Î∞úÍ∏âÌï©ÎãàÎã§.  
Î¶¨ÌîÑÎ†àÏâ¨ ÌÜ†ÌÅ∞Ïù¥ ÎßåÎ£åÎêòÏóàÍ±∞ÎÇò Ïú†Ìö®ÌïòÏßÄ ÏïäÏùÄ Í≤ΩÏö∞ 401 ÏóêÎü¨Í∞Ä Î∞úÏÉùÌï©ÎãàÎã§.  
Ïû¨Î∞úÍ∏âÌïú ÌÜ†ÌÅ∞ÏùÄ Ïø†ÌÇ§Î°ú Ï†ÄÏû•Îê©ÎãàÎã§.
 * @summary ÌÜ†ÌÅ∞ Ïû¨Î∞úÍ∏â
 */
export type reissueTokenResponse200 = {
  data: Blob
  status: 200
}

export type reissueTokenResponse401 = {
  data: Blob
  status: 401
}

export type reissueTokenResponse500 = {
  data: Blob
  status: 500
}
    
export type reissueTokenResponseSuccess = (reissueTokenResponse200) & {
  headers: Headers;
};
export type reissueTokenResponseError = (reissueTokenResponse401 | reissueTokenResponse500) & {
  headers: Headers;
};

export type reissueTokenResponse = (reissueTokenResponseSuccess | reissueTokenResponseError)

export const getReissueTokenUrl = () => {


  

  return `/api/v1/auth/reissue`
}

export const reissueToken = async ( options?: RequestInit): Promise<reissueTokenResponse> => {
  
  return orvalClient<reissueTokenResponse>(getReissueTokenUrl(),
  {      
    ...options,
    method: 'POST'
    
    
  }
);}




export const getReissueTokenMutationOptions = <TError = Blob,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof reissueToken>>, TError,void, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof reissueToken>>, TError,void, TContext> => {

const mutationKey = ['reissueToken'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof reissueToken>>, void> = () => {
          

          return  reissueToken()
        }



        


  return  { mutationFn, ...mutationOptions }}

    export type ReissueTokenMutationResult = NonNullable<Awaited<ReturnType<typeof reissueToken>>>
    
    export type ReissueTokenMutationError = Blob

    /**
 * @summary ÌÜ†ÌÅ∞ Ïû¨Î∞úÍ∏â
 */
export const useReissueToken = <TError = Blob,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof reissueToken>>, TError,void, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof reissueToken>>,
        TError,
        void,
        TContext
      > => {
      return useMutation(getReissueTokenMutationOptions(options), queryClient);
    }
    
/**
 * Î°úÍ∑∏ÏïÑÏõÉÌï©ÎãàÎã§.  
ÏÑúÎ≤ÑÍ∞Ä Ï†ÄÏû•ÌïòÍ≥† ÏûàÎäî Î¶¨ÌîÑÎ†àÏâ¨ ÌÜ†ÌÅ∞ÏùÑ Î¨¥Ìö®ÌôîÌï©ÎãàÎã§.  
ÌÅ¥ÎùºÏù¥Ïñ∏Ìä∏Ïùò Ïï°ÏÑ∏Ïä§, Î¶¨ÌîÑÎ†àÏâ¨ ÌÜ†ÌÅ∞ÏùÑ ÏÇ≠Ï†úÌï¥ÏïºÌï©ÎãàÎã§.
 * @summary Î°úÍ∑∏ÏïÑÏõÉ
 */
export type logoutResponse204 = {
  data: Blob
  status: 204
}
    
export type logoutResponseSuccess = (logoutResponse204) & {
  headers: Headers;
};
;

export type logoutResponse = (logoutResponseSuccess)

export const getLogoutUrl = () => {


  

  return `/api/v1/auth/logout`
}

export const logout = async ( options?: RequestInit): Promise<logoutResponse> => {
  
  return orvalClient<logoutResponse>(getLogoutUrl(),
  {      
    ...options,
    method: 'POST'
    
    
  }
);}




export const getLogoutMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof logout>>, TError,void, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof logout>>, TError,void, TContext> => {

const mutationKey = ['logout'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof logout>>, void> = () => {
          

          return  logout()
        }



        


  return  { mutationFn, ...mutationOptions }}

    export type LogoutMutationResult = NonNullable<Awaited<ReturnType<typeof logout>>>
    
    export type LogoutMutationError = unknown

    /**
 * @summary Î°úÍ∑∏ÏïÑÏõÉ
 */
export const useLogout = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof logout>>, TError,void, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof logout>>,
        TError,
        void,
        TContext
      > => {
      return useMutation(getLogoutMutationOptions(options), queryClient);
    }
    
/**
 * ÎÇ¥ Ï†ïÎ≥¥Î•º Ï°∞ÌöåÌï©ÎãàÎã§.
 * @summary ÎÇ¥ Ï†ïÎ≥¥ Ï°∞Ìöå
 */
export type getMemberInfoResponse200 = {
  data: MemberInfoResponse
  status: 200
}
    
export type getMemberInfoResponseSuccess = (getMemberInfoResponse200) & {
  headers: Headers;
};
;

export type getMemberInfoResponse = (getMemberInfoResponseSuccess)

export const getGetMemberInfoUrl = () => {


  

  return `/api/v1/members/me`
}

export const getMemberInfo = async ( options?: RequestInit): Promise<getMemberInfoResponse> => {
  
  return orvalClient<getMemberInfoResponse>(getGetMemberInfoUrl(),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}





export const getGetMemberInfoQueryKey = () => {
    return [
    `/api/v1/members/me`
    ] as const;
    }

    
export const getGetMemberInfoQueryOptions = <TData = Awaited<ReturnType<typeof getMemberInfo>>, TError = unknown>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getMemberInfo>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetMemberInfoQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getMemberInfo>>> = ({ signal }) => getMemberInfo({ signal });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getMemberInfo>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetMemberInfoQueryResult = NonNullable<Awaited<ReturnType<typeof getMemberInfo>>>
export type GetMemberInfoQueryError = unknown


export function useGetMemberInfo<TData = Awaited<ReturnType<typeof getMemberInfo>>, TError = unknown>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getMemberInfo>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getMemberInfo>>,
          TError,
          Awaited<ReturnType<typeof getMemberInfo>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetMemberInfo<TData = Awaited<ReturnType<typeof getMemberInfo>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getMemberInfo>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getMemberInfo>>,
          TError,
          Awaited<ReturnType<typeof getMemberInfo>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetMemberInfo<TData = Awaited<ReturnType<typeof getMemberInfo>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getMemberInfo>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary ÎÇ¥ Ï†ïÎ≥¥ Ï°∞Ìöå
 */

export function useGetMemberInfo<TData = Awaited<ReturnType<typeof getMemberInfo>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getMemberInfo>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetMemberInfoQueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  return { ...query, queryKey: queryOptions.queryKey };
}





/**
 * ÏàòÏ†ïÏù¥ ÌïÑÏöîÌïòÏßÄ ÏïäÏùÄ ÌïÑÎìúÎäî nullÎ°ú ÏöîÏ≤≠ÌïòÎ©¥ Îê©ÎãàÎã§.  
(bodyÏóê Ìè¨Ìï®ÌïòÏßÄ ÏïäÏùå)
 * @summary ÎÇ¥ Ï†ïÎ≥¥ ÏàòÏ†ï
 */
export type updateMemberResponse200 = {
  data: MemberInfoResponse
  status: 200
}
    
export type updateMemberResponseSuccess = (updateMemberResponse200) & {
  headers: Headers;
};
;

export type updateMemberResponse = (updateMemberResponseSuccess)

export const getUpdateMemberUrl = () => {


  

  return `/api/v1/members/me`
}

export const updateMember = async (updateMemberBody: Blob, options?: RequestInit): Promise<updateMemberResponse> => {
  
  return orvalClient<updateMemberResponse>(getUpdateMemberUrl(),
  {      
    ...options,
    method: 'PATCH',
    headers: { 'Content-Type': 'application/json;charset=UTF-8', ...options?.headers },
    body: JSON.stringify(
      updateMemberBody,)
  }
);}




export const getUpdateMemberMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateMember>>, TError,{data: Blob}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof updateMember>>, TError,{data: Blob}, TContext> => {

const mutationKey = ['updateMember'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof updateMember>>, {data: Blob}> = (props) => {
          const {data} = props ?? {};

          return  updateMember(data,)
        }



        


  return  { mutationFn, ...mutationOptions }}

    export type UpdateMemberMutationResult = NonNullable<Awaited<ReturnType<typeof updateMember>>>
    export type UpdateMemberMutationBody = Blob
    export type UpdateMemberMutationError = unknown

    /**
 * @summary ÎÇ¥ Ï†ïÎ≥¥ ÏàòÏ†ï
 */
export const useUpdateMember = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateMember>>, TError,{data: Blob}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof updateMember>>,
        TError,
        {data: Blob},
        TContext
      > => {
      return useMutation(getUpdateMemberMutationOptions(options), queryClient);
    }
    
/**
 * Í≤åÏãúÎ¨ºÏùò ÏÉÅÏÑ∏ ÎÇ¥Ïö©ÏùÑ ÌôïÏù∏Ìï©ÎãàÎã§
 * @summary Í≤åÏãúÎ¨º ÏÉÅÏÑ∏ Ï°∞Ìöå
 */
export type getSpecificLedgerResponse200 = {
  data: LedgerResponse
  status: 200
}

export type getSpecificLedgerResponse404 = {
  data: Blob
  status: 404
}
    
export type getSpecificLedgerResponseSuccess = (getSpecificLedgerResponse200) & {
  headers: Headers;
};
export type getSpecificLedgerResponseError = (getSpecificLedgerResponse404) & {
  headers: Headers;
};

export type getSpecificLedgerResponse = (getSpecificLedgerResponseSuccess | getSpecificLedgerResponseError)

export const getGetSpecificLedgerUrl = (ledgerId: number,) => {


  

  return `/api/v1/ledgers/${ledgerId}`
}

export const getSpecificLedger = async (ledgerId: number, options?: RequestInit): Promise<getSpecificLedgerResponse> => {
  
  return orvalClient<getSpecificLedgerResponse>(getGetSpecificLedgerUrl(ledgerId),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}





export const getGetSpecificLedgerQueryKey = (ledgerId: number,) => {
    return [
    `/api/v1/ledgers/${ledgerId}`
    ] as const;
    }

    
export const getGetSpecificLedgerQueryOptions = <TData = Awaited<ReturnType<typeof getSpecificLedger>>, TError = Blob>(ledgerId: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getSpecificLedger>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetSpecificLedgerQueryKey(ledgerId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getSpecificLedger>>> = ({ signal }) => getSpecificLedger(ledgerId, { signal });

      

      

   return  { queryKey, queryFn, enabled: !!(ledgerId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getSpecificLedger>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetSpecificLedgerQueryResult = NonNullable<Awaited<ReturnType<typeof getSpecificLedger>>>
export type GetSpecificLedgerQueryError = Blob


export function useGetSpecificLedger<TData = Awaited<ReturnType<typeof getSpecificLedger>>, TError = Blob>(
 ledgerId: number, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getSpecificLedger>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getSpecificLedger>>,
          TError,
          Awaited<ReturnType<typeof getSpecificLedger>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetSpecificLedger<TData = Awaited<ReturnType<typeof getSpecificLedger>>, TError = Blob>(
 ledgerId: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getSpecificLedger>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getSpecificLedger>>,
          TError,
          Awaited<ReturnType<typeof getSpecificLedger>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetSpecificLedger<TData = Awaited<ReturnType<typeof getSpecificLedger>>, TError = Blob>(
 ledgerId: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getSpecificLedger>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Í≤åÏãúÎ¨º ÏÉÅÏÑ∏ Ï°∞Ìöå
 */

export function useGetSpecificLedger<TData = Awaited<ReturnType<typeof getSpecificLedger>>, TError = Blob>(
 ledgerId: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getSpecificLedger>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetSpecificLedgerQueryOptions(ledgerId,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  return { ...query, queryKey: queryOptions.queryKey };
}





/**
 * Í∏∞Ï°¥ Í≤åÏãúÎ¨ºÏùÑ Ïû•Î∂Ä Í≤åÏãúÌåêÏóêÏÑú ÏÇ≠Ï†úÌï©ÎãàÎã§
 * @summary Í≤åÏãúÎ¨º ÏÇ≠Ï†ú
 */
export type deleteLedgerResponse204 = {
  data: Blob
  status: 204
}

export type deleteLedgerResponse401 = {
  data: Blob
  status: 401
}

export type deleteLedgerResponse404 = {
  data: Blob
  status: 404
}
    
export type deleteLedgerResponseSuccess = (deleteLedgerResponse204) & {
  headers: Headers;
};
export type deleteLedgerResponseError = (deleteLedgerResponse401 | deleteLedgerResponse404) & {
  headers: Headers;
};

export type deleteLedgerResponse = (deleteLedgerResponseSuccess | deleteLedgerResponseError)

export const getDeleteLedgerUrl = (ledgerId: number,) => {


  

  return `/api/v1/ledgers/${ledgerId}`
}

export const deleteLedger = async (ledgerId: number, options?: RequestInit): Promise<deleteLedgerResponse> => {
  
  return orvalClient<deleteLedgerResponse>(getDeleteLedgerUrl(ledgerId),
  {      
    ...options,
    method: 'DELETE'
    
    
  }
);}




export const getDeleteLedgerMutationOptions = <TError = Blob,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteLedger>>, TError,{ledgerId: number}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof deleteLedger>>, TError,{ledgerId: number}, TContext> => {

const mutationKey = ['deleteLedger'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteLedger>>, {ledgerId: number}> = (props) => {
          const {ledgerId} = props ?? {};

          return  deleteLedger(ledgerId,)
        }



        


  return  { mutationFn, ...mutationOptions }}

    export type DeleteLedgerMutationResult = NonNullable<Awaited<ReturnType<typeof deleteLedger>>>
    
    export type DeleteLedgerMutationError = Blob

    /**
 * @summary Í≤åÏãúÎ¨º ÏÇ≠Ï†ú
 */
export const useDeleteLedger = <TError = Blob,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteLedger>>, TError,{ledgerId: number}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof deleteLedger>>,
        TError,
        {ledgerId: number},
        TContext
      > => {
      return useMutation(getDeleteLedgerMutationOptions(options), queryClient);
    }
    
/**
 * Í∏∞Ï°¥ Í≤åÏãúÎ¨ºÏùò ÎÇ¥Ïö©ÏùÑ ÏàòÏ†ïÌï©ÎãàÎã§
 * @summary Í≤åÏãúÎ¨º ÏàòÏ†ï
 */
export type modifyLedgerResponse200 = {
  data: LedgerResponse
  status: 200
}

export type modifyLedgerResponse401 = {
  data: Blob
  status: 401
}
    
export type modifyLedgerResponseSuccess = (modifyLedgerResponse200) & {
  headers: Headers;
};
export type modifyLedgerResponseError = (modifyLedgerResponse401) & {
  headers: Headers;
};

export type modifyLedgerResponse = (modifyLedgerResponseSuccess | modifyLedgerResponseError)

export const getModifyLedgerUrl = (ledgerId: number,) => {


  

  return `/api/v1/ledgers/${ledgerId}`
}

export const modifyLedger = async (ledgerId: number,
    modifyLedgerBody: Blob, options?: RequestInit): Promise<modifyLedgerResponse> => {
  
  return orvalClient<modifyLedgerResponse>(getModifyLedgerUrl(ledgerId),
  {      
    ...options,
    method: 'PATCH',
    headers: { 'Content-Type': 'application/json;charset=UTF-8', ...options?.headers },
    body: JSON.stringify(
      modifyLedgerBody,)
  }
);}




export const getModifyLedgerMutationOptions = <TError = Blob,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof modifyLedger>>, TError,{ledgerId: number;data: Blob}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof modifyLedger>>, TError,{ledgerId: number;data: Blob}, TContext> => {

const mutationKey = ['modifyLedger'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof modifyLedger>>, {ledgerId: number;data: Blob}> = (props) => {
          const {ledgerId,data} = props ?? {};

          return  modifyLedger(ledgerId,data,)
        }



        


  return  { mutationFn, ...mutationOptions }}

    export type ModifyLedgerMutationResult = NonNullable<Awaited<ReturnType<typeof modifyLedger>>>
    export type ModifyLedgerMutationBody = Blob
    export type ModifyLedgerMutationError = Blob

    /**
 * @summary Í≤åÏãúÎ¨º ÏàòÏ†ï
 */
export const useModifyLedger = <TError = Blob,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof modifyLedger>>, TError,{ledgerId: number;data: Blob}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof modifyLedger>>,
        TError,
        {ledgerId: number;data: Blob},
        TContext
      > => {
      return useMutation(getModifyLedgerMutationOptions(options), queryClient);
    }
    
/**
 * ÌöåÏõêÍ∞ÄÏûÖ ÌõÑ Ï∂îÍ∞Ä Ï†ïÎ≥¥Î•º ÏûÖÎ†•Ìï©ÎãàÎã§.
 * @summary ÌöåÏõêÍ∞ÄÏûÖ ÌõÑ Ï∂îÍ∞Ä Ï†ïÎ≥¥ ÏûÖÎ†•
 */
export type completeRegistrationResponse200 = {
  data: MemberInfoResponse
  status: 200
}
    
export type completeRegistrationResponseSuccess = (completeRegistrationResponse200) & {
  headers: Headers;
};
;

export type completeRegistrationResponse = (completeRegistrationResponseSuccess)

export const getCompleteRegistrationUrl = () => {


  

  return `/api/v1/auth/complete-registration`
}

export const completeRegistration = async (completeRegistrationBody: Blob, options?: RequestInit): Promise<completeRegistrationResponse> => {
  
  return orvalClient<completeRegistrationResponse>(getCompleteRegistrationUrl(),
  {      
    ...options,
    method: 'PATCH',
    headers: { 'Content-Type': 'application/json;charset=UTF-8', ...options?.headers },
    body: JSON.stringify(
      completeRegistrationBody,)
  }
);}




export const getCompleteRegistrationMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof completeRegistration>>, TError,{data: Blob}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof completeRegistration>>, TError,{data: Blob}, TContext> => {

const mutationKey = ['completeRegistration'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof completeRegistration>>, {data: Blob}> = (props) => {
          const {data} = props ?? {};

          return  completeRegistration(data,)
        }



        


  return  { mutationFn, ...mutationOptions }}

    export type CompleteRegistrationMutationResult = NonNullable<Awaited<ReturnType<typeof completeRegistration>>>
    export type CompleteRegistrationMutationBody = Blob
    export type CompleteRegistrationMutationError = unknown

    /**
 * @summary ÌöåÏõêÍ∞ÄÏûÖ ÌõÑ Ï∂îÍ∞Ä Ï†ïÎ≥¥ ÏûÖÎ†•
 */
export const useCompleteRegistration = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof completeRegistration>>, TError,{data: Blob}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof completeRegistration>>,
        TError,
        {data: Blob},
        TContext
      > => {
      return useMutation(getCompleteRegistrationMutationOptions(options), queryClient);
    }
    
/**
 * titleÏóê Ìï¥ÎãπÌïòÎäî ÏúÑÌÇ§Î•º Ï°∞ÌöåÌï©ÎãàÎã§.
 * @summary ÏúÑÌÇ§ Ï°∞Ìöå
 */
export type getWikiResponse200 = {
  data: WikiResponse
  status: 200
}

export type getWikiResponse404 = {
  data: Blob
  status: 404
}
    
export type getWikiResponseSuccess = (getWikiResponse200) & {
  headers: Headers;
};
export type getWikiResponseError = (getWikiResponse404) & {
  headers: Headers;
};

export type getWikiResponse = (getWikiResponseSuccess | getWikiResponseError)

export const getGetWikiUrl = (title: string,) => {


  

  return `/api/v1/wikis/${title}`
}

export const getWiki = async (title: string, options?: RequestInit): Promise<getWikiResponse> => {
  
  return orvalClient<getWikiResponse>(getGetWikiUrl(title),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}





export const getGetWikiQueryKey = (title: string,) => {
    return [
    `/api/v1/wikis/${title}`
    ] as const;
    }

    
export const getGetWikiQueryOptions = <TData = Awaited<ReturnType<typeof getWiki>>, TError = Blob>(title: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getWiki>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetWikiQueryKey(title);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getWiki>>> = ({ signal }) => getWiki(title, { signal });

      

      

   return  { queryKey, queryFn, enabled: !!(title), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getWiki>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetWikiQueryResult = NonNullable<Awaited<ReturnType<typeof getWiki>>>
export type GetWikiQueryError = Blob


export function useGetWiki<TData = Awaited<ReturnType<typeof getWiki>>, TError = Blob>(
 title: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getWiki>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getWiki>>,
          TError,
          Awaited<ReturnType<typeof getWiki>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetWiki<TData = Awaited<ReturnType<typeof getWiki>>, TError = Blob>(
 title: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getWiki>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getWiki>>,
          TError,
          Awaited<ReturnType<typeof getWiki>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetWiki<TData = Awaited<ReturnType<typeof getWiki>>, TError = Blob>(
 title: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getWiki>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary ÏúÑÌÇ§ Ï°∞Ìöå
 */

export function useGetWiki<TData = Awaited<ReturnType<typeof getWiki>>, TError = Blob>(
 title: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getWiki>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetWikiQueryOptions(title,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  return { ...query, queryKey: queryOptions.queryKey };
}





/**
 * titleÏóê Ìï¥ÎãπÌïòÎäî ÏúÑÌÇ§Ïùò ÏàòÏ†ï ÎÇ¥Ïó≠ÏùÑ Ï°∞ÌöåÌï©ÎãàÎã§.
 * @summary ÏàòÏ†ï ÎÇ¥Ïó≠ Ï°∞Ìöå
 */
export type getWikiHistoryResponse200 = {
  data: WikiResponse[]
  status: 200
}
    
export type getWikiHistoryResponseSuccess = (getWikiHistoryResponse200) & {
  headers: Headers;
};
;

export type getWikiHistoryResponse = (getWikiHistoryResponseSuccess)

export const getGetWikiHistoryUrl = (title: string,) => {


  

  return `/api/v1/wikis/${title}/history`
}

export const getWikiHistory = async (title: string, options?: RequestInit): Promise<getWikiHistoryResponse> => {
  
  return orvalClient<getWikiHistoryResponse>(getGetWikiHistoryUrl(title),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}





export const getGetWikiHistoryQueryKey = (title: string,) => {
    return [
    `/api/v1/wikis/${title}/history`
    ] as const;
    }

    
export const getGetWikiHistoryQueryOptions = <TData = Awaited<ReturnType<typeof getWikiHistory>>, TError = unknown>(title: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getWikiHistory>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetWikiHistoryQueryKey(title);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getWikiHistory>>> = ({ signal }) => getWikiHistory(title, { signal });

      

      

   return  { queryKey, queryFn, enabled: !!(title), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getWikiHistory>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetWikiHistoryQueryResult = NonNullable<Awaited<ReturnType<typeof getWikiHistory>>>
export type GetWikiHistoryQueryError = unknown


export function useGetWikiHistory<TData = Awaited<ReturnType<typeof getWikiHistory>>, TError = unknown>(
 title: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getWikiHistory>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getWikiHistory>>,
          TError,
          Awaited<ReturnType<typeof getWikiHistory>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetWikiHistory<TData = Awaited<ReturnType<typeof getWikiHistory>>, TError = unknown>(
 title: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getWikiHistory>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getWikiHistory>>,
          TError,
          Awaited<ReturnType<typeof getWikiHistory>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetWikiHistory<TData = Awaited<ReturnType<typeof getWikiHistory>>, TError = unknown>(
 title: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getWikiHistory>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary ÏàòÏ†ï ÎÇ¥Ïó≠ Ï°∞Ìöå
 */

export function useGetWikiHistory<TData = Awaited<ReturnType<typeof getWikiHistory>>, TError = unknown>(
 title: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getWikiHistory>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetWikiHistoryQueryOptions(title,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  return { ...query, queryKey: queryOptions.queryKey };
}





/**
 * ÏµúÍ∑º ÏàòÏ†ïÎêú ÏúÑÌÇ§ 10Í∞úÏùò Ï†úÎ™©ÏùÑ Î¶¨Ïä§Ìä∏Î°ú Ï°∞ÌöåÌï©ÎãàÎã§.
 * @summary ÏµúÍ∑º ÏàòÏ†ï ÏúÑÌÇ§
 */
export type getRecentWikiResponse200 = {
  data: WikiTitleResponse[]
  status: 200
}
    
export type getRecentWikiResponseSuccess = (getRecentWikiResponse200) & {
  headers: Headers;
};
;

export type getRecentWikiResponse = (getRecentWikiResponseSuccess)

export const getGetRecentWikiUrl = () => {


  

  return `/api/v1/wikis/recent`
}

export const getRecentWiki = async ( options?: RequestInit): Promise<getRecentWikiResponse> => {
  
  return orvalClient<getRecentWikiResponse>(getGetRecentWikiUrl(),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}





export const getGetRecentWikiQueryKey = () => {
    return [
    `/api/v1/wikis/recent`
    ] as const;
    }

    
export const getGetRecentWikiQueryOptions = <TData = Awaited<ReturnType<typeof getRecentWiki>>, TError = unknown>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getRecentWiki>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetRecentWikiQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getRecentWiki>>> = ({ signal }) => getRecentWiki({ signal });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getRecentWiki>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetRecentWikiQueryResult = NonNullable<Awaited<ReturnType<typeof getRecentWiki>>>
export type GetRecentWikiQueryError = unknown


export function useGetRecentWiki<TData = Awaited<ReturnType<typeof getRecentWiki>>, TError = unknown>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getRecentWiki>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getRecentWiki>>,
          TError,
          Awaited<ReturnType<typeof getRecentWiki>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetRecentWiki<TData = Awaited<ReturnType<typeof getRecentWiki>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getRecentWiki>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getRecentWiki>>,
          TError,
          Awaited<ReturnType<typeof getRecentWiki>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetRecentWiki<TData = Awaited<ReturnType<typeof getRecentWiki>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getRecentWiki>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary ÏµúÍ∑º ÏàòÏ†ï ÏúÑÌÇ§
 */

export function useGetRecentWiki<TData = Awaited<ReturnType<typeof getRecentWiki>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getRecentWiki>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetRecentWikiQueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  return { ...query, queryKey: queryOptions.queryKey };
}





/**
 * Î¨¥ÏûëÏúÑ ÏúÑÌÇ§Î•º ÏùëÎãµÌï©ÎãàÎã§
 * @summary Î¨¥ÏûëÏúÑ ÏúÑÌÇ§
 */
export type getRandomWikiResponse200 = {
  data: WikiTitleResponse
  status: 200
}

export type getRandomWikiResponse404 = {
  data: Blob
  status: 404
}
    
export type getRandomWikiResponseSuccess = (getRandomWikiResponse200) & {
  headers: Headers;
};
export type getRandomWikiResponseError = (getRandomWikiResponse404) & {
  headers: Headers;
};

export type getRandomWikiResponse = (getRandomWikiResponseSuccess | getRandomWikiResponseError)

export const getGetRandomWikiUrl = () => {


  

  return `/api/v1/wikis/random`
}

export const getRandomWiki = async ( options?: RequestInit): Promise<getRandomWikiResponse> => {
  
  return orvalClient<getRandomWikiResponse>(getGetRandomWikiUrl(),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}





export const getGetRandomWikiQueryKey = () => {
    return [
    `/api/v1/wikis/random`
    ] as const;
    }

    
export const getGetRandomWikiQueryOptions = <TData = Awaited<ReturnType<typeof getRandomWiki>>, TError = Blob>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getRandomWiki>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetRandomWikiQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getRandomWiki>>> = ({ signal }) => getRandomWiki({ signal });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getRandomWiki>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetRandomWikiQueryResult = NonNullable<Awaited<ReturnType<typeof getRandomWiki>>>
export type GetRandomWikiQueryError = Blob


export function useGetRandomWiki<TData = Awaited<ReturnType<typeof getRandomWiki>>, TError = Blob>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getRandomWiki>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getRandomWiki>>,
          TError,
          Awaited<ReturnType<typeof getRandomWiki>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetRandomWiki<TData = Awaited<ReturnType<typeof getRandomWiki>>, TError = Blob>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getRandomWiki>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getRandomWiki>>,
          TError,
          Awaited<ReturnType<typeof getRandomWiki>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetRandomWiki<TData = Awaited<ReturnType<typeof getRandomWiki>>, TError = Blob>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getRandomWiki>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Î¨¥ÏûëÏúÑ ÏúÑÌÇ§
 */

export function useGetRandomWiki<TData = Awaited<ReturnType<typeof getRandomWiki>>, TError = Blob>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getRandomWiki>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetRandomWikiQueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  return { ...query, queryKey: queryOptions.queryKey };
}





/**
 * Í≤ÄÏÉâÏñ¥Ïóê Ìï¥ÎãπÌïòÎäî ÏúÑÌÇ§ 7Í∞úÎ•º ÏûêÎèôÏôÑÏÑ±ÌïòÏó¨ ÏùëÎãµÌï©ÎãàÎã§
 * @summary ÏúÑÌÇ§ Í≤ÄÏÉâÏñ¥ ÏûêÎèôÏôÑÏÑ±
 */
export type getAutocompleteWikiResponse200 = {
  data: WikiTitleResponse
  status: 200
}

export type getAutocompleteWikiResponse404 = {
  data: Blob
  status: 404
}
    
export type getAutocompleteWikiResponseSuccess = (getAutocompleteWikiResponse200) & {
  headers: Headers;
};
export type getAutocompleteWikiResponseError = (getAutocompleteWikiResponse404) & {
  headers: Headers;
};

export type getAutocompleteWikiResponse = (getAutocompleteWikiResponseSuccess | getAutocompleteWikiResponseError)

export const getGetAutocompleteWikiUrl = (params: GetAutocompleteWikiParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `/api/v1/wikis/autocomplete?${stringifiedParams}` : `/api/v1/wikis/autocomplete`
}

export const getAutocompleteWiki = async (params: GetAutocompleteWikiParams, options?: RequestInit): Promise<getAutocompleteWikiResponse> => {
  
  return orvalClient<getAutocompleteWikiResponse>(getGetAutocompleteWikiUrl(params),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}





export const getGetAutocompleteWikiQueryKey = (params?: GetAutocompleteWikiParams,) => {
    return [
    `/api/v1/wikis/autocomplete`, ...(params ? [params] : [])
    ] as const;
    }

    
export const getGetAutocompleteWikiQueryOptions = <TData = Awaited<ReturnType<typeof getAutocompleteWiki>>, TError = Blob>(params: GetAutocompleteWikiParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAutocompleteWiki>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetAutocompleteWikiQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getAutocompleteWiki>>> = ({ signal }) => getAutocompleteWiki(params, { signal });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getAutocompleteWiki>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetAutocompleteWikiQueryResult = NonNullable<Awaited<ReturnType<typeof getAutocompleteWiki>>>
export type GetAutocompleteWikiQueryError = Blob


export function useGetAutocompleteWiki<TData = Awaited<ReturnType<typeof getAutocompleteWiki>>, TError = Blob>(
 params: GetAutocompleteWikiParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAutocompleteWiki>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAutocompleteWiki>>,
          TError,
          Awaited<ReturnType<typeof getAutocompleteWiki>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetAutocompleteWiki<TData = Awaited<ReturnType<typeof getAutocompleteWiki>>, TError = Blob>(
 params: GetAutocompleteWikiParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAutocompleteWiki>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAutocompleteWiki>>,
          TError,
          Awaited<ReturnType<typeof getAutocompleteWiki>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetAutocompleteWiki<TData = Awaited<ReturnType<typeof getAutocompleteWiki>>, TError = Blob>(
 params: GetAutocompleteWikiParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAutocompleteWiki>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary ÏúÑÌÇ§ Í≤ÄÏÉâÏñ¥ ÏûêÎèôÏôÑÏÑ±
 */

export function useGetAutocompleteWiki<TData = Awaited<ReturnType<typeof getAutocompleteWiki>>, TError = Blob>(
 params: GetAutocompleteWikiParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAutocompleteWiki>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetAutocompleteWikiQueryOptions(params,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  return { ...query, queryKey: queryOptions.queryKey };
}





/**
 * Î≥∏Ïù∏Ïù¥ ÏïÑÎãå ÌöåÏõêÏùÑ Î≤àÌò∏Î°ú Ï°∞ÌöåÌï©ÎãàÎã§.
 * @summary Îã§Î•∏ ÌöåÏõê Ï†ïÎ≥¥ Ï°∞Ìöå
 */
export type getOtherMemberInfoResponse200 = {
  data: MemberInfoResponse
  status: 200
}

export type getOtherMemberInfoResponse404 = {
  data: Blob
  status: 404
}
    
export type getOtherMemberInfoResponseSuccess = (getOtherMemberInfoResponse200) & {
  headers: Headers;
};
export type getOtherMemberInfoResponseError = (getOtherMemberInfoResponse404) & {
  headers: Headers;
};

export type getOtherMemberInfoResponse = (getOtherMemberInfoResponseSuccess | getOtherMemberInfoResponseError)

export const getGetOtherMemberInfoUrl = (memberId: number,) => {


  

  return `/api/v1/members/${memberId}`
}

export const getOtherMemberInfo = async (memberId: number, options?: RequestInit): Promise<getOtherMemberInfoResponse> => {
  
  return orvalClient<getOtherMemberInfoResponse>(getGetOtherMemberInfoUrl(memberId),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}





export const getGetOtherMemberInfoQueryKey = (memberId: number,) => {
    return [
    `/api/v1/members/${memberId}`
    ] as const;
    }

    
export const getGetOtherMemberInfoQueryOptions = <TData = Awaited<ReturnType<typeof getOtherMemberInfo>>, TError = Blob>(memberId: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getOtherMemberInfo>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetOtherMemberInfoQueryKey(memberId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getOtherMemberInfo>>> = ({ signal }) => getOtherMemberInfo(memberId, { signal });

      

      

   return  { queryKey, queryFn, enabled: !!(memberId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getOtherMemberInfo>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetOtherMemberInfoQueryResult = NonNullable<Awaited<ReturnType<typeof getOtherMemberInfo>>>
export type GetOtherMemberInfoQueryError = Blob


export function useGetOtherMemberInfo<TData = Awaited<ReturnType<typeof getOtherMemberInfo>>, TError = Blob>(
 memberId: number, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getOtherMemberInfo>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getOtherMemberInfo>>,
          TError,
          Awaited<ReturnType<typeof getOtherMemberInfo>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetOtherMemberInfo<TData = Awaited<ReturnType<typeof getOtherMemberInfo>>, TError = Blob>(
 memberId: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getOtherMemberInfo>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getOtherMemberInfo>>,
          TError,
          Awaited<ReturnType<typeof getOtherMemberInfo>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetOtherMemberInfo<TData = Awaited<ReturnType<typeof getOtherMemberInfo>>, TError = Blob>(
 memberId: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getOtherMemberInfo>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Îã§Î•∏ ÌöåÏõê Ï†ïÎ≥¥ Ï°∞Ìöå
 */

export function useGetOtherMemberInfo<TData = Awaited<ReturnType<typeof getOtherMemberInfo>>, TError = Blob>(
 memberId: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getOtherMemberInfo>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetOtherMemberInfoQueryOptions(memberId,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  return { ...query, queryKey: queryOptions.queryKey };
}





export type capsServerResponse200 = {
  data: Blob
  status: 200
}
    
export type capsServerResponseSuccess = (capsServerResponse200) & {
  headers: Headers;
};
;

export type capsServerResponse = (capsServerResponseSuccess)

export const getCapsServerUrl = () => {


  

  return `/`
}

export const capsServer = async ( options?: RequestInit): Promise<capsServerResponse> => {
  
  return orvalClient<capsServerResponse>(getCapsServerUrl(),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}





export const getCapsServerQueryKey = () => {
    return [
    `/`
    ] as const;
    }

    
export const getCapsServerQueryOptions = <TData = Awaited<ReturnType<typeof capsServer>>, TError = unknown>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof capsServer>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getCapsServerQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof capsServer>>> = ({ signal }) => capsServer({ signal });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof capsServer>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type CapsServerQueryResult = NonNullable<Awaited<ReturnType<typeof capsServer>>>
export type CapsServerQueryError = unknown


export function useCapsServer<TData = Awaited<ReturnType<typeof capsServer>>, TError = unknown>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof capsServer>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof capsServer>>,
          TError,
          Awaited<ReturnType<typeof capsServer>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useCapsServer<TData = Awaited<ReturnType<typeof capsServer>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof capsServer>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof capsServer>>,
          TError,
          Awaited<ReturnType<typeof capsServer>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useCapsServer<TData = Awaited<ReturnType<typeof capsServer>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof capsServer>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

export function useCapsServer<TData = Awaited<ReturnType<typeof capsServer>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof capsServer>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getCapsServerQueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  return { ...query, queryKey: queryOptions.queryKey };
}





export type deleteFileResponse200 = {
  data: Blob
  status: 200
}
    
export type deleteFileResponseSuccess = (deleteFileResponse200) & {
  headers: Headers;
};
;

export type deleteFileResponse = (deleteFileResponseSuccess)

export const getDeleteFileUrl = (params: DeleteFileParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `/api/v1/files?${stringifiedParams}` : `/api/v1/files`
}

export const deleteFile = async (params: DeleteFileParams, options?: RequestInit): Promise<deleteFileResponse> => {
  
  return orvalClient<deleteFileResponse>(getDeleteFileUrl(params),
  {      
    ...options,
    method: 'DELETE'
    
    
  }
);}




export const getDeleteFileMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteFile>>, TError,{params: DeleteFileParams}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof deleteFile>>, TError,{params: DeleteFileParams}, TContext> => {

const mutationKey = ['deleteFile'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteFile>>, {params: DeleteFileParams}> = (props) => {
          const {params} = props ?? {};

          return  deleteFile(params,)
        }



        


  return  { mutationFn, ...mutationOptions }}

    export type DeleteFileMutationResult = NonNullable<Awaited<ReturnType<typeof deleteFile>>>
    
    export type DeleteFileMutationError = unknown

    export const useDeleteFile = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteFile>>, TError,{params: DeleteFileParams}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof deleteFile>>,
        TError,
        {params: DeleteFileParams},
        TContext
      > => {
      return useMutation(getDeleteFileMutationOptions(options), queryClient);
    }
